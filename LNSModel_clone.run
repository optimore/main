#-----------------------------------

# Kommandofil: LNSmodel.run

#-----------------------------------

reset;                  # Nollställer

option solver cplexamp;    # Val av lösare.

#option presolve 0;      

option omit_zero_cols 1;   # Skriver ej ut nollor i kolumner

option omit_zero_rows 1;   # Skriver ej ut nollor i rader

option display_1col 10000; # Skriver ut bara en kolumn (mer lättläst)

option cplex_options "timing 1 mipdisplay 2"; #Tidtagning och utskrifter, lägg till time limit

option display_precision 5;



model LNSmodel.mod;   # Läser in namnet på modellfilen. 

data Goood.dat;    # Läser in namnet på datafilen. 



problem y_search: fake_cost,  x_s, x_e, y, y_s, y_e, first_task, last_task, check_if_endtask, check_if_starttask, start_constraint_noa, identical_index;



problem LNS_search: total_cost, u, a1, a2, a3, a4, a5, first_task, last_task, check_if_endtask, check_if_starttask, start_constraint, task_distance, task_length, interval_constraint1, interval_constraint2, dependency_constraint1, dependency_constraint2, identical_index;





let number_of_iterations := 0;

for {i in I}

{

	let x_s[i] := (t_e[i] + t_s[i])/2 - l[i]/2;

	let x_e[i] := x_s[i] + l[i];

	



}



for {i in D}

{

	let x_s[I_df[i]] := t_s[I_df[i]];

	let x_e[I_df[i]] := t_s[I_df[i]] + l[I_df[i]];



	let x_s[I_dt[i]] := t_e[I_dt[i]] - l[I_dt[i]];

	let x_e[I_dt[i]] := t_e[I_dt[i]];





}



let C1 := 20;

let C2 := 20;

let C3 := 20;

let C4 := 20;

let C5 := 20;



# Count the number of y-, (y_s- and y_e)-variables

let count := 0;

for {k in G, i in I, j in I}

{

	let count := count + 1;



}





#for {i in I, k in G}

#{

#	let count := count + 1;

#}



### Solve first iteration to get start solution ###

solve y_search;

#display y, x_s, x_e;



#for {d in D}

#{

#	unfix a4[d];

#	unfix a5[d];

#}



#for {k in G, i in I_g[k], j in I_g[k]}

#{

#	unfix a1[k,i,j];

#	unfix a2[i];

#	unfix a3[i];

#	#fix x_s[i];

#	#fix x_e[i];

#}



for {i in I}

{

	let x_s[i] := (t_e[i] + t_s[i])/2 - l[i]/2;

	let x_e[i] := x_s[i] + l[i];

	



}



for {i in D}

{

	let x_s[I_df[i]] := t_s[I_df[i]];

	let x_e[I_df[i]] := t_s[I_df[i]] + l[I_df[i]];



	let x_s[I_dt[i]] := t_e[I_dt[i]] - l[I_dt[i]];

	let x_e[I_dt[i]] := t_e[I_dt[i]];





}





solve LNS_search;





#display y, l, x_s, x_e, t_s, t_e;



let sum_a1 := sum{k in G}(sum{L in I_g[k]} (sum{j in I_g[k]} a1[k,L,j]));

let sum_a2 := sum{L in I} a2[L];

let sum_a3 := sum{L in I} a3[L];

let sum_a4 := sum{d in D} a4[d];

let sum_a5 := sum{d in D} a5[d];

	

#Display the sum of artificial variables to see which constraint is violated the most

#display sum_a1;

#display sum_a2;

#display sum_a3;

#display sum_a4;

#display sum_a5;



let total_violation := sum_a1 + sum_a2 + sum_a3 + sum_a4 + sum_a5; 





let best_solution := total_violation;

display best_solution;

let number_of_iterations := number_of_iterations + 1;

let current_solution := best_solution;

let time_elapsed := _ampl_time + _total_solve_elapsed_time;

let iteration_time := _ampl_time + _total_solve_elapsed_time - time_elapsed;

let times_at_optima := 0;

display current_solution, number_of_iterations,  time_elapsed  > LNSModel.txt;

###############





if total_violation !=0 then

repeat

{

	### Add another iteration

	let number_of_iterations := number_of_iterations + 1;



	# Generate the degree of destruction from the interval [min_destroy, max_destroy] e.g. [0.1,0.3]. Note: read ropke

	let min_destroy := 0.1;

	let max_destroy := 0.3;





	# Set the previous solution

	if number_of_iterations = 0 then

	{

		let previous_solution := best_solution;

	}

	else

	{

		let previous_solution := current_solution;

	}



	if current_solution = previous_solution then

	{

		if times_at_optima < 3 then

		{

			let destroy_degree := 1 - min_destroy + times_at_optima*(max_destroy-min_destroy)/2;

			let times_at_optima := times_at_optima + 1;

			printf "Hej Akdas %d \n \n", times_at_optima;





		}

		else

		{

			printf "Hej Claes \n \n";

			# Okey way to calculate the C-parameters?





			let C1 := sum_a1/total_violation*100;

			let C2 := sum_a2/total_violation*100;

			let C3 := sum_a3/total_violation*100;

			let C4 := sum_a4/total_violation*100;

			let C5 := sum_a5/total_violation*100;

			let times_at_optima := 0;

			

		

			









			unfix y;

		}

	}

	else

	{

		let destroy_degree := 1 - round(Uniform(min_destroy,max_destroy),1); #rounds the uniform value to 1 digit past the decimal point.

	}	

	

	### Destroy function ###

	display count;

	let destroy := round(destroy_degree * count);

	for {j in 1..destroy}

	{

		#CURRENTLY STATIC VALUE IN Uniform(1,X). X SHOULD BE DYNAMIC.



		let randi := round(Uniform(1,8));

		let randj := round(Uniform(1,8));

		let randg := round(Uniform(1,2));

		fix y[randg,randi,randj];

	}

	

	### Solve the problem aka Repair function ###

	solve LNS_search;

	display total_cost;

	let current_solution := total_violation;

	display current_solution, number_of_iterations,  _solve_elapsed_time > LNSModel.txt;	



	if  number_of_iterations = 164 || number_of_iterations = 165 then

	{

	}



	# Display the cost





	

	# Check if the current solution is the best solution found

	if current_solution < best_solution then

	{

		let best_solution := current_solution;

	}

	



	#display C1;

	#display C2;

	#display C3;

	#display C4;

	#display C5;



	let sum_a1 := sum{k in G}(sum{L in I_g[k]} (sum{j in I_g[k]} a1[k,L,j]));

	let sum_a2 := sum{L in I} a2[L];

	let sum_a3 := sum{L in I} a3[L];

	let sum_a4 := sum{d in D} a4[d];

	let sum_a5 := sum{d in D} a5[d];

	

	#Display the sum of artificial variables to see which constraint is violated the most

	#display sum_a1;

	#display sum_a2;

	#display sum_a3;

	#display sum_a4;

	#display sum_a5;



	let total_violation := sum_a1 + sum_a2 + sum_a3 + sum_a4 + sum_a5; 





	#Recalculate the weight parameters when suited, else if all are 0 then we have found the solution and will stop iterating.

	if total_violation = 0 then

	{

		printf "Time elapsed is: ";

		print time() - t0;

		### display the variables ###

		#display _varname, _var;

		#Skriver ut hela problem på fil, ej nödvändigt men bra för kontroll.

		display best_solution, number_of_iterations > LNSModel.txt;

		expand > LNSModel.exp;

		printf "In else before exit! \n\n\n\n\n";

		printf "Number of iterations: ";

		print number_of_iterations;

		printf "\n";

		exit;

	}



	#display the variables

	#display _varname, _var;

	#display total_cost;

	#display total_cost > LNSModel.res;

	#display l;

	#display t_s;

	#display t_e;

	#display f_min;

	#display f_max;

	#display I_df;

	#display I_dt;

	#display g;

	let iteration_time := _ampl_time + _total_solve_elapsed_time - time_elapsed;

	let time_elapsed := _ampl_time + _total_solve_elapsed_time;

	printf "We are at the end of the while!!!!! \n\n\n\n\n\n";

	}

	until total_violation == 0 || time_elapsed >= 30;



display best_solution, number_of_iterations,  time_elapsed > LNSModel.txt;





# Only gets here if total_violation != 0 and time_elapsed >= t.

#printf "We have looped for %d seconds and done %d number of iterations without having found any solution... \n \n", time_elapsed, number_of_iterations;

#printf "Best solution found was: %d \n \n", best_solution;



exit;



